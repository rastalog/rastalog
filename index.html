<!DOCTYPE html>
<html lang="fa" dir="rtl">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>GeoProfile Visualizer</title>
  <link rel="preconnect" href="https://cdn.jsdelivr.net"/>
  <script src="https://cdn.jsdelivr.net/npm/papaparse@5.4.1/papaparse.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/xlsx@0.18.5/dist/xlsx.full.min.js"></script>
  <script src="https://cdn.plot.ly/plotly-2.32.0.min.js"></script>
  <style>
    :root { color-scheme: light dark; }
    body { font-family: sans-serif; margin: 24px; }
    .panel { border: 1px solid #ddd; padding: 16px; border-radius: 8px; margin-bottom: 16px; }
    label { display: block; margin-bottom: 8px; font-weight: 600; }
    input[type="file"] { margin-bottom: 12px; }
    #plot { width: 100%; height: 70vh; }
    .row { display: flex; gap: 16px; flex-wrap: wrap; }
    .col { flex: 1 1 320px; }
    .btn { background: #1f77b4; color: #fff; border: none; padding: 10px 14px; border-radius: 6px; cursor: pointer; }
    .btn:disabled { background: #aaa; cursor: not-allowed; }
    .note { color: #555; font-size: 0.9em; }
    .inline { display: inline-flex; align-items: center; gap: 8px; }
    select, input[type="number"] { padding: 6px; }
    code { background: rgba(0,0,0,.05); padding: .1rem .3rem; border-radius: 4px; }
    .chk { margin-inline-start: 8px; }
  </style>
</head>
<body>
  <h1>GeoProfile Visualizer</h1>
  <p class="note">
    ۲بعدی بر اساس عمق منفی رو به پایین رسم می‌شود: <code>y = −depth</code> (دهانهٔ گمانه: <code>y=0</code>).
    ۳بعدی فقط زیرزمین را نشان می‌دهد (هر لایه تا <code>z=0</code> کات می‌شود) و یک «قاچ» نمایشی برای دیدن داخل دارد.
  </p>

  <div class="row">
    <div class="col panel">
      <label>فایل گمانه‌ها (ستون‌ها: <code>BoreholeID, X, Y, Z</code>)</label>
      <input id="holesFile" type="file" accept=".csv,.xlsx,.xls" />
      <label>فایل لایه‌ها (ستون‌ها: <code>BoreholeID, TopDepth_m, BottomDepth_m, USCS[, Description]</code>)</label>
      <input id="layersFile" type="file" accept=".csv,.xlsx,.xls" />

      <div class="inline" style="margin-top:8px;">
        <label style="margin:0;">حالت رسم:</label>
        <select id="modeSel">
          <option value="2d">پروفیل ۲بعدی</option>
          <option value="3d">پروفیل ۳بعدی</option>
        </select>
        <label style="margin:0;">چیدمان افقی ۲D:</label>
        <select id="layoutMode">
          <option value="x">بر اساس X</option>
          <option value="y">بر اساس Y</option>
          <option value="chainage">Chainage تجمعی</option>
        </select>
        <label style="margin:0;">عرض ستون:</label>
        <input id="colWidth" type="number" min="1" max="100" step="1" value="10"/>
      </div>

      <div class="inline" style="margin-top:8px;">
        <input id="cutaway" class="chk" type="checkbox" checked />
        <label for="cutaway" style="margin:0;">برش نمایشی در ۳بعدی (باز شدن سمت +Y)</label>
      </div>

      <div style="margin-top:12px;">
        <button id="renderBtn" class="btn" disabled>رسم پروفیل</button>
        <button id="downloadBtn" class="btn" disabled>دانلود PNG</button>
      </div>
      <p class="note" id="status"></p>
    </div>

    <div class="col panel">
      <label>راهنما:</label>
      <ul>
        <li><b>محاسبات ارتفاع:</b> <code>TopZ = Z − TopDepth_m</code> ، <code>BottomZ = Z − BottomDepth_m</code></li>
        <li><b>۲D:</b> عمق منفی رو به پایین (مثلاً عمق ۷ متر ⇒ <code>y=−7</code>)، خط زمین <code>y=0</code>.</li>
        <li><b>۳D:</b> لایه‌ها فقط برای بخش زیر <code>z=0</code> نمایش داده می‌شوند + صفحهٔ زمین (نیمه‌شفاف) و برش دید.</li>
      </ul>
    </div>
  </div>

  <div id="plot" class="panel"></div>

  <script>
    // رنگ‌ها برای USCS
    const USCS_COLORS = {
      "GW": "#8B5A2B", "GP": "#8B5A2B",
      "SW": "#F4A460", "SP": "#F4A460",
      "SM": "#E0B07B", "SC": "#D28F6D",
      "GM": "#A0734A", "GC": "#8A6A48",
      "ML": "#B5C7E6", "CL": "#7FB3D5",
      "OL": "#A3C1B0", "MH": "#4A76A8",
      "CH": "#2E86C1", "OH": "#5C8D89",
      "PT": "#3B4A3F", "FILL": "#AAAAAA"
    };

    const state = { holes: null, layers: null };

    const holesInput = document.getElementById('holesFile');
    const layersInput = document.getElementById('layersFile');
    const renderBtn = document.getElementById('renderBtn');
    const downloadBtn = document.getElementById('downloadBtn');
    const statusEl = document.getElementById('status');
    const layoutModeSel = document.getElementById('layoutMode');
    const modeSel = document.getElementById('modeSel');
    const colWidthInput = document.getElementById('colWidth');
    const cutawayChk = document.getElementById('cutaway');

    // کمکی‌ها
    function pickColor(code) {
      if (!code) return "#CCCCCC";
      const norm = String(code).toUpperCase().replace("/", "-").split("-");
      for (const p of norm) if (USCS_COLORS[p]) return USCS_COLORS[p];
      return "#CCCCCC";
    }
    function parseCSV(file){return new Promise((res,rej)=>Papa.parse(file,{header:true,skipEmptyLines:true,complete:r=>res(r.data),error:rej}));}
    function parseXLSX(file){return new Promise((res,rej)=>{const rd=new FileReader();rd.onload=e=>{const wb=XLSX.read(e.target.result,{type:'array'});const sh=wb.Sheets[wb.SheetNames[0]];res(XLSX.utils.sheet_to_json(sh,{defval:""}));};rd.onerror=rej;rd.readAsArrayBuffer(file);});}
    async function parseFile(file){const n=(file?.name||"").toLowerCase();if(n.endsWith('.csv'))return parseCSV(file);if(n.endsWith('.xlsx')||n.endsWith('.xls'))return parseXLSX(file);throw new Error('فرمت پشتیبانی نمی‌شود (CSV/XLSX).');}
    function normalizeKeys(row){const o={};for(const k of Object.keys(row))o[String(k).trim()]=row[k];return o;}
    function toNumber(v){if(v===null||v===undefined||v==="")return null;const n=Number(String(v).replace(',','.'));return Number.isFinite(n)?n:null;}
    function indexBy(arr,key){const m=new Map();for(const r of arr){const id=String(r[key]).trim();if(!m.has(id))m.set(id,[]);m.get(id).push(r);}return m;}
    function dist(a,b){return Math.hypot(a.X-b.X,a.Y-b.Y);}

    holesInput.addEventListener('change', async (e)=>{
      statusEl.textContent='در حال خواندن فایل گمانه‌ها...';
      try{const f=e.target.files?.[0];const d=await parseFile(f);state.holes=d.map(normalizeKeys);statusEl.textContent=`گمانه‌ها: ${state.holes.length} رکورد`;}
      catch(err){statusEl.textContent='خطا در خواندن گمانه‌ها: '+err.message;}
      renderBtn.disabled=!(state.holes&&state.layers);
    });
    layersInput.addEventListener('change', async (e)=>{
      statusEl.textContent='در حال خواندن فایل لایه‌ها...';
      try{const f=e.target.files?.[0];const d=await parseFile(f);state.layers=d.map(normalizeKeys);statusEl.textContent=`لایه‌ها: ${state.layers.length} رکورد`;}
      catch(err){statusEl.textContent='خطا در خواندن لایه‌ها: '+err.message;}
      renderBtn.disabled=!(state.holes&&state.layers);
    });

    renderBtn.addEventListener('click', ()=>{
      try{renderProfile();downloadBtn.disabled=false;statusEl.textContent='رسم انجام شد.';}
      catch(err){statusEl.textContent='❌ '+err.message;}
    });
    downloadBtn.addEventListener('click', async ()=>{
      const gd=document.getElementById('plot');
      try{await Plotly.downloadImage(gd,{format:'png',filename:'geoprofile',width:1600,height:900});}
      catch{statusEl.textContent='خطا در دانلود تصویر';}
    });

    // آماده‌سازی
    function prepareData(){
      const holes=(state.holes||[]).map(h=>({
        BoreholeID:String(h.BoreholeID??h.boreholeid??h.ID??h.id??"").trim(),
        X:toNumber(h.X??h.x), Y:toNumber(h.Y??h.y),
        Z:toNumber(h.Z??h.z??h.GroundLevel??h.groundlevel??h.Elevation??h.elevation)
      })).filter(h=>h.BoreholeID && h.X!=null && h.Y!=null && h.Z!=null);
      if(!holes.length) throw new Error('ستون‌های BoreholeID, X, Y, Z معتبر نیستند.');

      const holeIndex=indexBy(holes,'BoreholeID');

      const layers=(state.layers||[]).map(r=>({
        BoreholeID:String(r.BoreholeID??r.boreholeid??r.ID??r.id??"").trim(),
        TopDepth_m:toNumber(r.TopDepth_m??r.topdepth_m??r.TopDepth??r.top),
        BottomDepth_m:toNumber(r.BottomDepth_m??r.bottomdepth_m??r.BottomDepth??r.bottom),
        USCS:String(r.USCS??r.uscs??'').trim(),
        Description:String(r.Description??r.description??'')
      })).filter(r=>r.BoreholeID && r.TopDepth_m!=null && r.BottomDepth_m!=null);
      if(!layers.length) throw new Error('ستون‌های لایه‌ها معتبر نیستند.');

      const df=[];
      for(const lay of layers){
        const hole=(holeIndex.get(lay.BoreholeID)||[])[0];
        if(!hole) continue;
        const Z=hole.Z;
        df.push({
          BoreholeID:lay.BoreholeID, X:hole.X, Y:hole.Y, Z,
          TopDepth_m:lay.TopDepth_m, BottomDepth_m:lay.BottomDepth_m,
          USCS:lay.USCS, Description:lay.Description,
          TopZ: Z - lay.TopDepth_m,
          BotZ: Z - lay.BottomDepth_m
        });
      }
      if(!df.length) throw new Error('هیچ لایه‌ای با گمانه‌ها تطبیق داده نشد.');
      return {holes, df};
    }

    // ترتیب chainage
    function orderByNearestNeighbor(holes){
      if(holes.length<=2) return holes.map(h=>h.BoreholeID);
      let s=0;for(let i=1;i<holes.length;i++){if(holes[i].X<holes[s].X||(holes[i].X===holes[s].X&&holes[i].Y<holes[s].Y))s=i;}
      const vis=new Set(), order=[];let cur=holes[s];vis.add(cur.BoreholeID);order.push(cur.BoreholeID);
      for(let k=1;k<holes.length;k++){let best=null,bd=Infinity;for(const h of holes){if(vis.has(h.BoreholeID))continue;const d=dist(cur,h);if(d<bd){bd=d;best=h;}}
        if(!best)break;vis.add(best.BoreholeID);order.push(best.BoreholeID);cur=best;}
      for(const h of holes) if(!vis.has(h.BoreholeID)) order.push(h.BoreholeID);
      return order;
    }

    // ۲بعدی: y = -depth
    function render2D(holes, df){
      const mode=layoutModeSel.value; // x,y,chainage
      let orderedIDs = (mode==='chainage')
        ? orderByNearestNeighbor(holes)
        : holes.slice().sort((a,b)=>mode==='y'?(a.Y-b.Y):(a.X-b.X)).map(h=>h.BoreholeID);

      const chainages=new Map();
      const minX=Math.min(...holes.map(h=>h.X));
      const minY=Math.min(...holes.map(h=>h.Y));
      let accum=0, prev=null;
      for(const id of orderedIDs){
        const h=holes.find(v=>v.BoreholeID===id);
        let pos;
        if(mode==='x') pos=h.X-minX;
        else if(mode==='y') pos=h.Y-minY;
        else { pos = prev ? (accum += dist(prev,h)) : 0; prev=h; }
        chainages.set(id,pos);
      }

      const traces=[];
      const width=Math.max(5,Math.min(50,Number(colWidthInput.value)||10));
      let minNegDepth=0;

      for(const id of orderedIDs){
        const grp=df.filter(d=>d.BoreholeID===id).sort((a,b)=>a.TopDepth_m-b.TopDepth_m);
        if(!grp.length) continue;
        const x=chainages.get(id);

        // خط زمین y=0
        traces.push({x:[x-width/2,x+width/2], y:[0,0], mode:'lines', line:{color:'black'}, hoverinfo:'skip', showlegend:false});

        for(const row of grp){
          const yTop = -row.TopDepth_m;
          const yBot = -row.BottomDepth_m;
          if(yBot < minNegDepth) minNegDepth = yBot;

          traces.push({
            x:[x-width/2,x+width/2,x+width/2,x-width/2,x-width/2],
            y:[yTop,yTop,yBot,yBot,yTop],
            mode:'lines', fill:'toself',
            line:{color:'rgba(0,0,0,0.25)'},
            fillcolor: pickColor(row.USCS),
            name: row.USCS,
            hovertemplate:
              `گمانه: ${row.BoreholeID}<br>`+
              `USCS: ${row.USCS}<br>`+
              `Top depth: ${row.TopDepth_m} m (y=${yTop})<br>`+
              `Bottom depth: ${row.BottomDepth_m} m (y=${yBot})<br>`+
              `TopZ: ${row.TopZ} / BottomZ: ${row.BotZ}<br>`+
              `شرح: ${row.Description}<extra></extra>`,
            showlegend:false
          });
        }
      }

      const layout={
        title:'GeoProfile - 2D (Depth downward)',
        xaxis:{ title: mode==='chainage'?'Chainage (m)':(mode==='y'?'Y':'X') },
        yaxis:{
          title:'Depth (m, negative downward)',
          autorange:false,
          range:[1, minNegDepth], // مثال: [1,-7] ⇒ ۱ بالا، ۷- پایین
          zeroline:true, zerolinewidth:2
        },
        template:'plotly_white',
        margin:{ l:70, r:20, t:50, b:60 }
      };
      Plotly.newPlot('plot', traces, layout, {responsive:true});
    }

    // ۳بعدی: فقط زیر z=0 + برش نمایشی
    function makePrismMeshCut(X,Y,w,TopZ,BotZ,color,name,hover,cutOpen){
      const half=w/2;
      // footprint مستطیل
      const x=[X-half, X+half, X+half, X-half,  X-half, X+half, X+half, X-half];
      const y=[Y-half, Y-half, Y+half, Y+half,  Y-half, Y-half, Y+half, Y+half];
      const z=[TopZ,TopZ,TopZ,TopZ,  BotZ,BotZ,BotZ,BotZ];

      // مثلث‌ها: همه‌ی وجوه بجز سمت +Y برای ایجاد «قاچ باز»
      const tris = {
        top:    [[0,1,2],[0,2,3]],
        bottom: [[4,5,6],[4,6,7]],
        side1:  [[0,1,5],[0,5,4]], // -Y
        side2:  cutOpen ? [] : [[1,2,6],[1,6,5]], // +Y (حذف برای برش)
        side3:  [[2,3,7],[2,7,6]],
        side4:  [[3,0,4],[3,4,7]]
      };
      const i=[],j=[],k=[];
      for(const face of Object.values(tris)) for(const t of face){i.push(t[0]);j.push(t[1]);k.push(t[2]);}

      return {type:'mesh3d', x,y,z,i,j,k, name, hovertemplate:hover, showscale:false, opacity:0.96, color};
    }

    function render3D(holes, df){
      const width=Math.max(1,Math.min(50,Number(colWidthInput.value)||10));
      const cutOpen = !!cutawayChk.checked;
      const traces=[];

      // صفحه‌ی زمین (z=0)
      const xs=holes.map(h=>h.X), ys=holes.map(h=>h.Y);
      const pad=width*2;
      const minX=Math.min(...xs)-pad, maxX=Math.max(...xs)+pad;
      const minY=Math.min(...ys)-pad, maxY=Math.max(...ys)+pad;
      traces.push({
        type:'surface',
        x:[[minX,maxX],[minX,maxX]],
        y:[[minY,minY],[maxY,maxY]],
        z:[[0,0],[0,0]],
        opacity:0.35,
        showscale:false,
        colorscale:[[0,'#777'],[1,'#777']],
        name:'Ground (z=0)',
        hoverinfo:'skip'
      });

      // محل گمانه‌ها
      for (const h of holes){
        traces.push({
          type:'scatter3d', x:[h.X], y:[h.Y], z:[h.Z],
          mode:'markers+text', marker:{size:3, color:'black'},
          text:[h.BoreholeID], textposition:'top center',
          name:'Borehole', showlegend:false,
          hovertemplate:`Borehole: ${h.BoreholeID}<br>X:${h.X} Y:${h.Y} Z:${h.Z}<extra></extra>`
        });
      }

      // منشور لایه‌ها (کات در z=0)
      const byBH=[...new Set(df.map(d=>d.BoreholeID))];
      for(const id of byBH){
        const grp=df.filter(d=>d.BoreholeID===id).sort((a,b)=>a.TopDepth_m-b.TopDepth_m);
        if(!grp.length) continue;
        const X=grp[0].X, Y=grp[0].Y;
        for(const row of grp){
          // فقط زیرزمین:
          const top=Math.min(row.TopZ, 0);
          const bot=Math.min(row.BotZ, 0);
          if(bot===top) continue; // تماماً بالای زمین
          const color=pickColor(row.USCS);
          const hover=
            `Borehole: ${row.BoreholeID}<br>`+
            `USCS: ${row.USCS}<br>`+
            `TopZ: ${top} m<br>`+
            `BottomZ: ${bot} m<br>`+
            `Top depth: ${row.TopDepth_m} m<br>`+
            `Bottom depth: ${row.BottomDepth_m} m<br>`+
            `Desc: ${row.Description}<extra></extra>`;
          traces.push(makePrismMeshCut(X,Y,width,top,bot,color,row.USCS,hover,cutOpen));
        }
      }

      const layout={
        title:'GeoProfile - 3D (Subsurface cutaway)',
        scene:{
          xaxis:{ title:'X (m)' },
          yaxis:{ title:'Y (m)' },
          zaxis:{ title:'Z (m relative to map zero)', autorange:'reversed' }, // رو به پایین
          aspectmode:'data',
          camera:{ eye:{ x:1.6, y:1.6, z:0.9 } }
        },
        margin:{ l:0, r:0, t:50, b:0 },
        template:'plotly_white'
      };
      Plotly.newPlot('plot', traces, layout, {responsive:true});
    }

    // سوییچ حالت
    function renderProfile(){
      const {holes, df}=prepareData();
      const mode=modeSel.value;
      if(mode==='2d') render2D(holes, df);
      else render3D(holes, df);
    }
  </script>
</body>
</html>
