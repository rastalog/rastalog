<!DOCTYPE html>
<html lang="fa">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>GeoProfile Visualizer</title>
  <link rel="preconnect" href="https://cdn.jsdelivr.net"/>
  <script src="https://cdn.jsdelivr.net/npm/papaparse@5.4.1/papaparse.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/xlsx@0.18.5/dist/xlsx.full.min.js"></script>
  <script src="https://cdn.plot.ly/plotly-2.32.0.min.js"></script>
  <style>
    body { font-family: sans-serif; margin: 24px; }
    .panel { border: 1px solid #ddd; padding: 16px; border-radius: 8px; margin-bottom: 16px; }
    label { display: block; margin-bottom: 8px; font-weight: 600; }
    input[type="file"] { margin-bottom: 12px; }
    #plot { width: 100%; height: 70vh; }
    .row { display: flex; gap: 16px; flex-wrap: wrap; }
    .col { flex: 1 1 320px; }
    .btn { background: #1f77b4; color: #fff; border: none; padding: 10px 14px; border-radius: 6px; cursor: pointer; }
    .btn:disabled { background: #aaa; cursor: not-allowed; }
    .note { color: #555; font-size: 0.9em; }
    .inline { display: inline-flex; align-items: center; gap: 8px; }
    select, input[type="number"] { padding: 6px; }
  </style>
</head>
<body>
  <h1>GeoProfile Visualizer</h1>
  <p class="note">
    مبنای عمودی Z است: تراز دهانهٔ گمانه نسبت به صفر نقشه (مثبت بالاتر، منفی پایین‌تر). عمق لایه‌ها از دهانه به پایین کم می‌شود: TopZ = Z − TopDepth_m.
  </p>

  <div class="row">
    <div class="col panel">
      <label>فایل گمانه‌ها (Boreholes: BoreholeID, X, Y, Z)</label>
      <input id="holesFile" type="file" accept=".csv,.xlsx,.xls" />
      <label>فایل لایه‌ها (Layers: BoreholeID, TopDepth_m, BottomDepth_m, USCS[, Description])</label>
      <input id="layersFile" type="file" accept=".csv,.xlsx,.xls" />

      <div class="inline" style="margin-top:8px;">
        <label style="margin:0;">حالت رسم:</label>
        <select id="modeSel">
          <option value="2d">پروفیل ۲بعدی</option>
          <option value="3d">پروفیل ۳بعدی</option>
        </select>
        <label style="margin:0;">چیدمان افقی ۲D:</label>
        <select id="layoutMode">
          <option value="x">بر اساس X</option>
          <option value="y">بر اساس Y</option>
          <option value="chainage">Chainage تجمعی</option>
        </select>
        <label style="margin:0;">عرض ستون:</label>
        <input id="colWidth" type="number" min="1" max="100" step="1" value="10"/>
      </div>

      <div style="margin-top:12px;">
        <button id="renderBtn" class="btn" disabled>رسم پروفیل</button>
        <button id="downloadBtn" class="btn" disabled>دانلود PNG</button>
      </div>
      <p class="note" id="status"></p>
    </div>

    <div class="col panel">
      <label>راهنما:</label>
      <ul>
        <li><b>ستون‌های گمانه‌ها:</b> BoreholeID, X, Y, Z (Z نسبت به تراز صفر نقشه)</li>
        <li><b>ستون‌های لایه‌ها:</b> BoreholeID, TopDepth_m, BottomDepth_m, USCS[, Description]</li>
        <li><b>محاسبهٔ ارتفاع لایه:</b>
          TopZ = Z − TopDepth_m، BottomZ = Z − BottomDepth_m
        </li>
        <li><b>۲D:</b> محور عمودی Z با نمایش معکوس برای دیدن عمق رو به پایین.</li>
        <li><b>۳D:</b> منشور هر لایه در مختصات (X,Y) با قاعدهٔ کوچک و ارتفاع بین TopZ و BottomZ.</li>
      </ul>
    </div>
  </div>

  <div id="plot" class="panel"></div>

  <script>
    const USCS_COLORS = {
      "GW": "#8B5A2B", "GP": "#8B5A2B",
      "SW": "#F4A460", "SP": "#F4A460",
      "SM": "#E0B07B", "SC": "#D28F6D",
      "GM": "#A0734A", "GC": "#8A6A48",
      "ML": "#B5C7E6", "CL": "#7FB3D5",
      "OL": "#A3C1B0", "MH": "#4A76A8",
      "CH": "#2E86C1", "OH": "#5C8D89",
      "PT": "#3B4A3F", "FILL": "#AAAAAA"
    };

    const state = { holes: null, layers: null };

    const holesInput = document.getElementById('holesFile');
    const layersInput = document.getElementById('layersFile');
    const renderBtn = document.getElementById('renderBtn');
    const downloadBtn = document.getElementById('downloadBtn');
    const statusEl = document.getElementById('status');
    const layoutModeSel = document.getElementById('layoutMode');
    const modeSel = document.getElementById('modeSel');
    const colWidthInput = document.getElementById('colWidth');

    function pickColor(code) {
      if (!code) return "#CCCCCC";
      const norm = String(code).toUpperCase().replace("/", "-").split("-");
      for (const part of norm) {
        if (USCS_COLORS[part]) return USCS_COLORS[part];
      }
      return "#CCCCCC";
    }

    function parseCSV(file) {
      return new Promise((resolve, reject) => {
        Papa.parse(file, {
          header: true,
          skipEmptyLines: true,
          complete: (res) => resolve(res.data),
          error: (err) => reject(err)
        });
      });
    }

    function parseXLSX(file) {
      return new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.onload = (e) => {
          const wb = XLSX.read(e.target.result, { type: 'array' });
          const sheetName = wb.SheetNames[0];
          const sheet = wb.Sheets[sheetName];
          const json = XLSX.utils.sheet_to_json(sheet, { defval: "" });
          resolve(json);
        };
        reader.onerror = reject;
        reader.readAsArrayBuffer(file);
      });
    }

    async function parseFile(file) {
      const name = file.name.toLowerCase();
      if (name.endsWith('.csv')) return parseCSV(file);
      if (name.endsWith('.xlsx') || name.endsWith('.xls')) return parseXLSX(file);
      throw new Error('فرمت فایل پشتیبانی نمی‌شود');
    }

    function normalizeKeys(row) {
      const norm = {};
      for (const k of Object.keys(row)) {
        const nk = k.trim();
        norm[nk] = row[k];
      }
      return norm;
    }

    function indexBy(arr, key) {
      const map = new Map();
      for (const r of arr) {
        const id = String(r[key]).trim();
        if (!map.has(id)) map.set(id, []);
        map.get(id).push(r);
      }
      return map;
    }

    function toNumber(val) {
      if (val === null || val === undefined) return null;
      const num = Number(String(val).replace(',', '.'));
      return isFinite(num) ? num : null;
    }

    holesInput.addEventListener('change', async (e) => {
      statusEl.textContent = 'در حال خواندن فایل گمانه‌ها...';
      try {
        const data = await parseFile(e.target.files[0]);
        state.holes = data.map(normalizeKeys);
        statusEl.textContent = `گمانه‌ها: ${state.holes.length} رکورد`;
      } catch (err) {
        statusEl.textContent = 'خطا در خواندن گمانه‌ها: ' + err.message;
      }
      renderBtn.disabled = !(state.holes && state.layers);
    });

    layersInput.addEventListener('change', async (e) => {
      statusEl.textContent = 'در حال خواندن فایل لایه‌ها...';
      try {
        const data = await parseFile(e.target.files[0]);
        state.layers = data.map(normalizeKeys);
        statusEl.textContent = `لایه‌ها: ${state.layers.length} رکورد`;
      } catch (err) {
        statusEl.textContent = 'خطا در خواندن لایه‌ها: ' + err.message;
      }
      renderBtn.disabled = !(state.holes && state.layers);
    });

    renderBtn.addEventListener('click', () => {
      try {
        renderProfile();
        downloadBtn.disabled = false;
        statusEl.textContent = 'رسم انجام شد.';
      } catch (err) {
        statusEl.textContent = 'خطا در رسم: ' + err.message;
      }
    });

    downloadBtn.addEventListener('click', async () => {
      const gd = document.getElementById('plot');
      try {
        await Plotly.downloadImage(gd, { format: 'png', filename: 'geoprofile', width: 1600, height: 900 });
      } catch (err) {
        statusEl.textContent = 'خطا در دانلود تصویر';
      }
    });

    function prepareData() {
      const holes = state.holes.map(h => ({
        BoreholeID: String(h.BoreholeID ?? h.boreholeid ?? h.ID ?? h.id).trim(),
        X: toNumber(h.X ?? h.x),
        Y: toNumber(h.Y ?? h.y),
        // Prioritize Z; fallbacks to GroundLevel or Elevation if user hasn't migrated yet
        Z: toNumber(h.Z ?? h.z ?? h.GroundLevel ?? h.groundlevel ?? h.Elevation ?? h.elevation)
      })).filter(h => h.BoreholeID && h.X != null && h.Y != null && h.Z != null);

      if (!holes.length) throw new Error('ستون‌های لازم در فایل گمانه‌ها یافت نشد. لطفاً BoreholeID, X, Y, Z را فراهم کنید.');

      const holeIndex = indexBy(holes, 'BoreholeID');

      const layers = state.layers.map(r => ({
        BoreholeID: String(r.BoreholeID ?? r.boreholeid ?? r.ID ?? r.id).trim(),
        TopDepth_m: toNumber(r.TopDepth_m ?? r.topdepth_m ?? r.TopDepth ?? r.top),
        BottomDepth_m: toNumber(r.BottomDepth_m ?? r.bottomdepth_m ?? r.BottomDepth ?? r.bottom),
        USCS: String(r.USCS ?? r.uscs ?? '').trim(),
        Description: String(r.Description ?? r.description ?? '')
      })).filter(r => r.BoreholeID && r.TopDepth_m != null && r.BottomDepth_m != null);

      const df = [];
      for (const lay of layers) {
        const hole = (holeIndex.get(lay.BoreholeID) || [])[0];
        if (!hole) continue;
        const Z = hole.Z;
        df.push({
          BoreholeID: lay.BoreholeID,
          X: hole.X, Y: hole.Y, Z,
          TopDepth_m: lay.TopDepth_m, BottomDepth_m: lay.BottomDepth_m,
          USCS: lay.USCS, Description: lay.Description,
          TopZ: Z - lay.TopDepth_m,
          BotZ: Z - lay.BottomDepth_m
        });
      }

      if (!df.length) throw new Error('هیچ لایهٔ همسان با گمانه‌ها یافت نشد.');
      return { holes, df };
    }

    function render2D(holes, df) {
      const mode = layoutModeSel.value; // x, y, chainage
      const sortedIDs = Array.from(new Set(df.map(d => d.BoreholeID))).sort((a,b) => {
        const ha = holes.find(h => h.BoreholeID === a);
        const hb = holes.find(h => h.BoreholeID === b);
        if (mode === 'y') return ha.Y - hb.Y;
        return ha.X - hb.X;
      });

      const chainages = new Map();
      let accum = 0;
      let prevCoord = null;
      const minX = Math.min(...holes.map(h => h.X));
      const minY = Math.min(...holes.map(h => h.Y));

      for (const id of sortedIDs) {
        const h = holes.find(hh => hh.BoreholeID === id);
        let pos;
        if (mode === 'x') pos = h.X - minX;
        else if (mode === 'y') pos = h.Y - minY;
        else {
          if (!prevCoord) { pos = 0; prevCoord = { x: h.X, y: h.Y }; }
          else { const dx = h.X - prevCoord.x, dy = h.Y - prevCoord.y; accum += Math.hypot(dx, dy); pos = accum; prevCoord = { x: h.X, y: h.Y }; }
        }
        chainages.set(id, pos);
      }

      const traces = [];
      const width = Math.max(5, Math.min(50, Number(colWidthInput.value) || 10));

      for (const id of sortedIDs) {
        const group = df.filter(d => d.BoreholeID === id).sort((a,b) => a.TopDepth_m - b.TopDepth_m);
        if (!group.length) continue;
        const x = chainages.get(id);
        const z0 = group[0].Z;

        traces.push({
          x: [x - width/2, x + width/2],
          y: [z0, z0],
          mode: 'lines',
          line: { color: 'black' },
          hoverinfo: 'skip',
          showlegend: false
        });

        for (const row of group) {
          const color = pickColor(row.USCS);
          const xx = [x - width/2, x + width/2, x + width/2, x - width/2, x - width/2];
          const yy = [row.TopZ, row.TopZ, row.BotZ, row.BotZ, row.TopZ];
          traces.push({
            x: xx, y: yy, mode: 'lines', fill: 'toself',
            line: { color: 'rgba(0,0,0,0.2)' },
            fillcolor: color,
            name: row.USCS,
            hovertemplate:
              `Borehole: ${row.BoreholeID}<br>` +
              `USCS: ${row.USCS}<br>` +
              `Top depth: ${row.TopDepth_m} m (TopZ=${row.TopZ})<br>` +
              `Bottom depth: ${row.BottomDepth_m} m (BottomZ=${row.BotZ})<br>` +
              `Desc: ${row.Description}`,
            showlegend: false
          });
        }
      }

      const layout = {
        title: 'GeoProfile Visualizer - 2D Profile (Z axis)',
        xaxis: { title: mode === 'chainage' ? 'Chainage (m)' : (mode === 'y' ? 'Y' : 'X') },
        yaxis: { title: 'Z (m relative to map zero)', autorange: 'reversed' },
        template: 'plotly_white',
        margin: { l: 70, r: 20, t: 50, b: 60 }
      };

      Plotly.newPlot('plot', traces, layout, { responsive: true });
    }

    // Build a rectangular prism mesh for a layer at (X,Y), with footprint width w and heights TopZ..BotZ
    function makePrismMesh(X, Y, w, TopZ, BotZ, color, name, hover) {
      const half = w / 2;
      const x = [
        X - half, X + half, X + half, X - half,  // top face
        X - half, X + half, X + half, X - half   // bottom face
      ];
      const y = [
        Y - half, Y - half, Y + half, Y + half,
        Y - half, Y - half, Y + half, Y + half
      ];
      const z = [
        TopZ, TopZ, TopZ, TopZ,
        BotZ, BotZ, BotZ, BotZ
      ];
      // faces (triangles) indices
      const i = [
        0, 1, 2, 0, 2, 3,      // top face
        4, 5, 6, 4, 6, 7,      // bottom face
        0, 1, 5, 0, 5, 4,      // side 1
        1, 2, 6, 1, 6, 5,      // side 2
        2, 3, 7, 2, 7, 6,      // side 3
        3, 0, 4, 3, 4, 7       // side 4
      ];
      const j = [
        1, 2, 3, 2, 3, 0,
        5, 6, 7, 6, 7, 4,
        1, 5, 4, 5, 4, 0,
        2, 6, 5, 6, 5, 1,
        3, 7, 6, 7, 6, 2,
        0, 4, 7, 4, 7, 3
      ];
      const k = [
        2, 3, 0, 3, 0, 1,
        6, 7, 4, 7, 4, 5,
        5, 4, 0, 4, 0, 1,
        6, 5, 1, 5, 1, 2,
        7, 6, 2, 6, 2, 3,
        4, 7, 3, 7, 3, 0
      ];
      return {
        type: 'mesh3d',
        x, y, z, i, j, k,
        name,
        hovertemplate: hover,
        showscale: false,
        opacity: 0.95,
        color: color
      };
    }

    function render3D(holes, df) {
      const width = Math.max(1, Math.min(50, Number(colWidthInput.value) || 10));
      const traces = [];

      // Ground level markers (optional small vertical line at Z)
      for (const h of holes) {
        traces.push({
          type: 'scatter3d',
          x: [h.X, h.X],
          y: [h.Y, h.Y],
          z: [h.Z, h.Z],
          mode: 'markers+text',
          marker: { size: 3, color: 'black' },
          text: [h.BoreholeID],
          textposition: 'top center',
          name: 'Borehole',
          showlegend: false,
          hovertemplate: `Borehole: ${h.BoreholeID}<br>X:${h.X} Y:${h.Y} Z:${h.Z}<extra></extra>`
        });
      }

      // Layer prisms
      const byBH = Array.from(new Set(df.map(d => d.BoreholeID)));
      for (const id of byBH) {
        const group = df.filter(d => d.BoreholeID === id).sort((a,b) => a.TopDepth_m - b.TopDepth_m);
        if (!group.length) continue;
        const X = group[0].X, Y = group[0].Y;
        for (const row of group) {
          const color = pickColor(row.USCS);
          const hover =
            `Borehole: ${row.BoreholeID}<br>` +
            `USCS: ${row.USCS}<br>` +
            `TopZ: ${row.TopZ} m<br>` +
            `BottomZ: ${row.BotZ} m<br>` +
            `Top depth: ${row.TopDepth_m} m<br>` +
            `Bottom depth: ${row.BottomDepth_m} m<br>` +
            `Desc: ${row.Description}<extra></extra>`;
          traces.push(makePrismMesh(X, Y, width, row.TopZ, row.BotZ, color, row.USCS, hover));
        }
      }

      const layout = {
        title: 'GeoProfile Visualizer - 3D Profile (X-Y-Z)',
        scene: {
          xaxis: { title: 'X (m)' },
          yaxis: { title: 'Y (m)' },
          zaxis: { title: 'Z (m relative to map zero)', autorange: 'reversed' },
          aspectmode: 'data',
          camera: { eye: { x: 1.6, y: 1.6, z: 0.8 } }
        },
        margin: { l: 0, r: 0, t: 50, b: 0 },
        template: 'plotly_white'
      };

      Plotly.newPlot('plot', traces, layout, { responsive: true });
    }

    function renderProfile() {
      const { holes, df } = prepareData();
      const mode = modeSel.value;
      if (mode === '2d') render2D(holes, df);
      else render3D(holes, df);
    }
  </script>
</body>
</html>
