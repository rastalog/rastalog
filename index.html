<!DOCTYPE html>
<html lang="fa" dir="rtl">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>GeoProfile Visualizer</title>
  <link rel="preconnect" href="https://cdn.jsdelivr.net"/>
  <script src="https://cdn.jsdelivr.net/npm/papaparse@5.4.1/papaparse.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/xlsx@0.18.5/dist/xlsx.full.min.js"></script>
  <script src="https://cdn.plot.ly/plotly-2.32.0.min.js"></script>
  <style>
    :root { color-scheme: light dark; }
    body { font-family: sans-serif; margin: 24px; }
    .panel { border: 1px solid #ddd; padding: 16px; border-radius: 8px; margin-bottom: 16px; }
    label { display: block; margin-bottom: 8px; font-weight: 600; }
    input[type="file"] { margin-bottom: 12px; }
    #plot { width: 100%; height: 70vh; }
    .row { display: flex; gap: 16px; flex-wrap: wrap; }
    .col { flex: 1 1 320px; }
    .btn { background: #1f77b4; color: #fff; border: none; padding: 10px 14px; border-radius: 6px; cursor: pointer; }
    .btn:disabled { background: #aaa; cursor: not-allowed; }
    .note { color: #555; font-size: 0.9em; }
    .inline { display: inline-flex; align-items: center; gap: 8px; }
    select, input[type="number"] { padding: 6px; }
    code { background: rgba(0,0,0,.05); padding: .1rem .3rem; border-radius: 4px; }
  </style>
</head>
<body>
  <h1>GeoProfile Visualizer</h1>
  <p class="note">
    مبنای عمودی <b>Z</b> است: تراز دهانهٔ گمانه نسبت به صفر نقشه (مثبت بالاتر، منفی پایین‌تر). محاسبهٔ ارتفاع لایه‌ها:
    <code>TopZ = Z − TopDepth_m</code> و <code>BottomZ = Z − BottomDepth_m</code>.
  </p>

  <div class="row">
    <div class="col panel">
      <label>فایل گمانه‌ها (ستون‌ها: <code>BoreholeID, X, Y, Z</code>)</label>
      <input id="holesFile" type="file" accept=".csv,.xlsx,.xls" />
      <label>فایل لایه‌ها (ستون‌ها: <code>BoreholeID, TopDepth_m, BottomDepth_m, USCS[, Description]</code>)</label>
      <input id="layersFile" type="file" accept=".csv,.xlsx,.xls" />

      <div class="inline" style="margin-top:8px;">
        <label style="margin:0;">حالت رسم:</label>
        <select id="modeSel">
          <option value="2d">پروفیل ۲بعدی</option>
          <option value="3d">پروفیل ۳بعدی</option>
        </select>
        <label style="margin:0;">چیدمان افقی ۲D:</label>
        <select id="layoutMode">
          <option value="x">بر اساس X</option>
          <option value="y">بر اساس Y</option>
          <option value="chainage">Chainage تجمعی</option>
        </select>
        <label style="margin:0;">عرض ستون:</label>
        <input id="colWidth" type="number" min="1" max="100" step="1" value="10"/>
      </div>

      <div style="margin-top:12px;">
        <button id="renderBtn" class="btn" disabled>رسم پروفیل</button>
        <button id="downloadBtn" class="btn" disabled>دانلود PNG</button>
      </div>
      <p class="note" id="status"></p>
    </div>

    <div class="col panel">
      <label>راهنما:</label>
      <ul>
        <li><b>ستون‌های گمانه‌ها:</b> BoreholeID, X, Y, Z (Z نسبت به تراز صفر نقشه)</li>
        <li><b>ستون‌های لایه‌ها:</b> BoreholeID, TopDepth_m, BottomDepth_m, USCS[, Description]</li>
        <li><b>محاسبهٔ ارتفاع لایه:</b> TopZ = Z − TopDepth_m، BottomZ = Z − BottomDepth_m</li>
        <li><b>۲D:</b> محور عمودی Z با نمایش معکوس برای دیدن عمق رو به پایین.</li>
        <li><b>۳D:</b> منشور هر لایه در مختصات (X,Y) با ارتفاع بین TopZ و BottomZ.</li>
      </ul>
    </div>
  </div>

  <div id="plot" class="panel"></div>

  <script>
    // رنگ‌های استاندارد برای کدهای USCS (اولین جزءِ کد، مبنا قرار می‌گیرد)
    const USCS_COLORS = {
      "GW": "#8B5A2B", "GP": "#8B5A2B",
      "SW": "#F4A460", "SP": "#F4A460",
      "SM": "#E0B07B", "SC": "#D28F6D",
      "GM": "#A0734A", "GC": "#8A6A48",
      "ML": "#B5C7E6", "CL": "#7FB3D5",
      "OL": "#A3C1B0", "MH": "#4A76A8",
      "CH": "#2E86C1", "OH": "#5C8D89",
      "PT": "#3B4A3F", "FILL": "#AAAAAA"
    };

    const state = { holes: null, layers: null };

    const holesInput = document.getElementById('holesFile');
    const layersInput = document.getElementById('layersFile');
    const renderBtn = document.getElementById('renderBtn');
    const downloadBtn = document.getElementById('downloadBtn');
    const statusEl = document.getElementById('status');
    const layoutModeSel = document.getElementById('layoutMode');
    const modeSel = document.getElementById('modeSel');
    const colWidthInput = document.getElementById('colWidth');

    // --- ابزارک‌های عمومی ---
    function pickColor(code) {
      if (!code) return "#CCCCCC";
      const norm = String(code).toUpperCase().replace("/", "-").split("-");
      for (const part of norm) {
        if (USCS_COLORS[part]) return USCS_COLORS[part];
      }
      return "#CCCCCC";
    }

    function parseCSV(file) {
      return new Promise((resolve, reject) => {
        Papa.parse(file, {
          header: true,
          skipEmptyLines: true,
          complete: (res) => resolve(res.data),
          error: (err) => reject(err)
        });
      });
    }

    function parseXLSX(file) {
      return new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.onload = (e) => {
          const wb = XLSX.read(e.target.result, { type: 'array' });
          const sheetName = wb.SheetNames[0];
          const sheet = wb.Sheets[sheetName];
          const json = XLSX.utils.sheet_to_json(sheet, { defval: "" });
          resolve(json);
        };
        reader.onerror = reject;
        reader.readAsArrayBuffer(file);
      });
    }

    async function parseFile(file) {
      const name = (file?.name || "").toLowerCase();
      if (name.endsWith('.csv')) return parseCSV(file);
      if (name.endsWith('.xlsx') || name.endsWith('.xls')) return parseXLSX(file);
      throw new Error('فرمت فایل پشتیبانی نمی‌شود (CSV یا XLSX).');
    }

    function normalizeKeys(row) {
      const norm = {};
      for (const k of Object.keys(row)) {
        const nk = String(k).trim();
        norm[nk] = row[k];
      }
      return norm;
    }

    function indexBy(arr, key) {
      const map = new Map();
      for (const r of arr) {
        const id = String(r[key]).trim();
        if (!map.has(id)) map.set(id, []);
        map.get(id).push(r);
      }
      return map;
    }

    function toNumber(val) {
      if (val === null || val === undefined || val === "") return null;
      const num = Number(String(val).replace(',', '.'));
      return Number.isFinite(num) ? num : null;
    }

    function dist(a, b) {
      const dx = a.X - b.X, dy = a.Y - b.Y;
      return Math.hypot(dx, dy);
    }

    // --- رویدادها ---
    holesInput.addEventListener('change', async (e) => {
      statusEl.textContent = 'در حال خواندن فایل گمانه‌ها...';
      try {
        const file = e.target.files?.[0];
        const data = await parseFile(file);
        state.holes = data.map(normalizeKeys);
        statusEl.textContent = `گمانه‌ها: ${state.holes.length} رکورد`;
      } catch (err) {
        statusEl.textContent = 'خطا در خواندن گمانه‌ها: ' + err.message;
      }
      renderBtn.disabled = !(state.holes && state.layers);
    });

    layersInput.addEventListener('change', async (e) => {
      statusEl.textContent = 'در حال خواندن فایل لایه‌ها...';
      try {
        const file = e.target.files?.[0];
        const data = await parseFile(file);
        state.layers = data.map(normalizeKeys);
        statusEl.textContent = `لایه‌ها: ${state.layers.length} رکورد`;
      } catch (err) {
        statusEl.textContent = 'خطا در خواندن لایه‌ها: ' + err.message;
      }
      renderBtn.disabled = !(state.holes && state.layers);
    });

    renderBtn.addEventListener('click', () => {
      try {
        renderProfile();
        downloadBtn.disabled = false;
        statusEl.textContent = 'رسم انجام شد.';
      } catch (err) {
        statusEl.textContent = '❌ ' + err.message;
      }
    });

    downloadBtn.addEventListener('click', async () => {
      const gd = document.getElementById('plot');
      try {
        await Plotly.downloadImage(gd, { format: 'png', filename: 'geoprofile', width: 1600, height: 900 });
      } catch (err) {
        statusEl.textContent = 'خطا در دانلود تصویر';
      }
    });

    // --- آماده‌سازی داده ---
    function prepareData() {
      const holes = (state.holes || []).map(h => ({
        BoreholeID: String(h.BoreholeID ?? h.boreholeid ?? h.ID ?? h.id ?? "").trim(),
        X: toNumber(h.X ?? h.x),
        Y: toNumber(h.Y ?? h.y),
        // Z نسبت به صفر نقشه؛ درصورت مهاجرت‌نکردن کاربر، GroundLevel/Elevation هم پشتیبانی می‌شود
        Z: toNumber(h.Z ?? h.z ?? h.GroundLevel ?? h.groundlevel ?? h.Elevation ?? h.elevation)
      })).filter(h => h.BoreholeID && h.X != null && h.Y != null && h.Z != null);

      if (!holes.length) {
        throw new Error('ستون‌های لازم در فایل گمانه‌ها یافت نشد. مطمئن شوید ستون‌های BoreholeID, X, Y, Z وجود دارند و مقادیر معتبر دارند.');
      }

      const holeIndex = indexBy(holes, 'BoreholeID');

      const layers = (state.layers || []).map(r => ({
        BoreholeID: String(r.BoreholeID ?? r.boreholeid ?? r.ID ?? r.id ?? "").trim(),
        TopDepth_m: toNumber(r.TopDepth_m ?? r.topdepth_m ?? r.TopDepth ?? r.top),
        BottomDepth_m: toNumber(r.BottomDepth_m ?? r.bottomdepth_m ?? r.BottomDepth ?? r.bottom),
        USCS: String(r.USCS ?? r.uscs ?? '').trim(),
        Description: String(r.Description ?? r.description ?? '')
      })).filter(r => r.BoreholeID && r.TopDepth_m != null && r.BottomDepth_m != null);

      if (!layers.length) {
        throw new Error('ستون‌های لازم در فایل لایه‌ها یافت نشد. مطمئن شوید ستون‌های BoreholeID, TopDepth_m, BottomDepth_m وجود دارند.');
      }

      const df = [];
      for (const lay of layers) {
        const hole = (holeIndex.get(lay.BoreholeID) || [])[0];
        if (!hole) continue;
        const Z = hole.Z;
        df.push({
          BoreholeID: lay.BoreholeID,
          X: hole.X, Y: hole.Y, Z,
          TopDepth_m: lay.TopDepth_m, BottomDepth_m: lay.BottomDepth_m,
          USCS: lay.USCS, Description: lay.Description,
          TopZ: Z - lay.TopDepth_m,
          BotZ: Z - lay.BottomDepth_m
        });
      }

      if (!df.length) throw new Error('هیچ لایه‌ای با گمانه‌های معرفی‌شده تطابق پیدا نکرد.');

      return { holes, df };
    }

    // --- چیدمان chainage با نزدیک‌ترین همسایه ---
    function orderByNearestNeighbor(holes) {
      if (holes.length <= 2) return holes.map(h => h.BoreholeID);
      // شروع از چپ‌ترین (کمینه X؛ در تساوی، کمینه Y)
      let startIdx = 0;
      for (let i = 1; i < holes.length; i++) {
        if (holes[i].X < holes[startIdx].X || (holes[i].X === holes[startIdx].X && holes[i].Y < holes[startIdx].Y)) {
          startIdx = i;
        }
      }
      const visited = new Set();
      const order = [];
      let current = holes[startIdx];
      visited.add(current.BoreholeID);
      order.push(current.BoreholeID);

      for (let step = 1; step < holes.length; step++) {
        let best = null, bestD = Infinity;
        for (const h of holes) {
          if (visited.has(h.BoreholeID)) continue;
          const d = dist(current, h);
          if (d < bestD) { bestD = d; best = h; }
        }
        if (!best) break;
        visited.add(best.BoreholeID);
        order.push(best.BoreholeID);
        current = best;
      }
      // اگر چیزی جا ماند (در عمل نباید)، اضافه کن
      for (const h of holes) if (!visited.has(h.BoreholeID)) order.push(h.BoreholeID);
      return order;
    }

    // --- رسم ۲D ---
    function render2D(holes, df) {
      const mode = layoutModeSel.value; // x, y, chainage

      // تعیین ترتیب گمانه‌ها برای محور افقی
      let orderedIDs;
      if (mode === 'chainage') {
        orderedIDs = orderByNearestNeighbor(holes);
      } else {
        orderedIDs = holes
          .slice()
          .sort((a,b) => mode === 'y' ? (a.Y - b.Y) : (a.X - b.X))
          .map(h => h.BoreholeID);
      }

      // محاسبهٔ موقعیت افقی (Xplot)
      const chainages = new Map();
      const minX = Math.min(...holes.map(h => h.X));
      const minY = Math.min(...holes.map(h => h.Y));

      let accum = 0;
      let prev = null;
      for (const id of orderedIDs) {
        const h = holes.find(v => v.BoreholeID === id);
        let pos;
        if (mode === 'x') pos = h.X - minX;
        else if (mode === 'y') pos = h.Y - minY;
        else {
          if (!prev) { pos = 0; }
          else { accum += dist(prev, h); pos = accum; }
          prev = h;
        }
        chainages.set(id, pos);
      }

      const traces = [];
      const width = Math.max(5, Math.min(50, Number(colWidthInput.value) || 10));

      for (const id of orderedIDs) {
        const group = df.filter(d => d.BoreholeID === id).sort((a,b) => a.TopDepth_m - b.TopDepth_m);
        if (!group.length) continue;
        const x = chainages.get(id);
        const z0 = group[0].Z;

        // خط تراز دهانه
        traces.push({
          x: [x - width/2, x + width/2],
          y: [z0, z0],
          mode: 'lines',
          line: { color: 'black' },
          hoverinfo: 'skip',
          showlegend: false
        });

        // لایه‌ها
        for (const row of group) {
          const color = pickColor(row.USCS);
          const xx = [x - width/2, x + width/2, x + width/2, x - width/2, x - width/2];
          const yy = [row.TopZ, row.TopZ, row.BotZ, row.BotZ, row.TopZ];
          traces.push({
            x: xx, y: yy, mode: 'lines', fill: 'toself',
            line: { color: 'rgba(0,0,0,0.25)' },
            fillcolor: color,
            name: row.USCS,
            hovertemplate:
              `گمانه: ${row.BoreholeID}<br>` +
              `USCS: ${row.USCS}<br>` +
              `Top depth: ${row.TopDepth_m} m (TopZ=${row.TopZ})<br>` +
              `Bottom depth: ${row.BottomDepth_m} m (BottomZ=${row.BotZ})<br>` +
              `شرح: ${row.Description}<extra></extra>`,
            showlegend: false
          });
        }
      }

      const layout = {
        title: 'GeoProfile - 2D',
        xaxis: { title: mode === 'chainage' ? 'Chainage (m)' : (mode === 'y' ? 'Y' : 'X') },
        yaxis: { title: 'Z (m relative to map zero)', autorange: 'reversed' },
        template: 'plotly_white',
        margin: { l: 70, r: 20, t: 50, b: 60 }
      };

      Plotly.newPlot('plot', traces, layout, { responsive: true });
    }

    // --- ساخت منشور mesh3d برای یک لایه ---
    function makePrismMesh(X, Y, w, TopZ, BotZ, color, name, hover) {
      const half = w / 2;
      const x = [
        X - half, X + half, X + half, X - half,  // top face (z = TopZ)
        X - half, X + half, X + half, X - half   // bottom face (z = BotZ)
      ];
      const y = [
        Y - half, Y - half, Y + half, Y + half,
        Y - half, Y - half, Y + half, Y + half
      ];
      const z = [
        TopZ, TopZ, TopZ, TopZ,
        BotZ, BotZ, BotZ, BotZ
      ];
      // مثلث‌بندی وجوه مکعب مستطیل
      const i = [0,1,2, 0,2,3,  4,5,6, 4,6,7,  0,1,5, 0,5,4,  1,2,6, 1,6,5,  2,3,7, 2,7,6,  3,0,4, 3,4,7];
      const j = [1,2,3, 2,3,0,  5,6,7, 6,7,4,  1,5,4, 5,4,0,  2,6,5, 6,5,1,  3,7,6, 7,6,2,  0,4,7, 4,7,3];
      const k = [2,3,0, 3,0,1,  6,7,4, 7,4,5,  5,4,0, 4,0,1,  6,5,1, 5,1,2,  7,6,2, 6,2,3,  4,7,3, 7,3,0];

      return {
        type: 'mesh3d',
        x, y, z, i, j, k,
        name,
        hovertemplate: hover,
        showscale: false,
        opacity: 0.96,
        color
      };
    }

    // --- رسم ۳D ---
    function render3D(holes, df) {
      const width = Math.max(1, Math.min(50, Number(colWidthInput.value) || 10));
      const traces = [];

      // نشانگر محل گمانه و برچسب
      for (const h of holes) {
        traces.push({
          type: 'scatter3d',
          x: [h.X],
          y: [h.Y],
          z: [h.Z],
          mode: 'markers+text',
          marker: { size: 3, color: 'black' },
          text: [h.BoreholeID],
          textposition: 'top center',
          name: 'Borehole',
          showlegend: false,
          hovertemplate: `Borehole: ${h.BoreholeID}<br>X:${h.X} Y:${h.Y} Z:${h.Z}<extra></extra>`
        });
      }

      // منشور لایه‌ها
      const byBH = Array.from(new Set(df.map(d => d.BoreholeID)));
      for (const id of byBH) {
        const group = df.filter(d => d.BoreholeID === id).sort((a,b) => a.TopDepth_m - b.TopDepth_m);
        if (!group.length) continue;
        const X = group[0].X, Y = group[0].Y;
        for (const row of group) {
          const color = pickColor(row.USCS);
          const hover =
            `Borehole: ${row.BoreholeID}<br>` +
            `USCS: ${row.USCS}<br>` +
            `TopZ: ${row.TopZ} m<br>` +
            `BottomZ: ${row.BotZ} m<br>` +
            `Top depth: ${row.TopDepth_m} m<br>` +
            `Bottom depth: ${row.BottomDepth_m} m<br>` +
            `Desc: ${row.Description}<extra></extra>`;
          traces.push(makePrismMesh(X, Y, width, row.TopZ, row.BotZ, color, row.USCS, hover));
        }
      }

      const layout = {
        title: 'GeoProfile - 3D',
        scene: {
          xaxis: { title: 'X (m)' },
          yaxis: { title: 'Y (m)' },
          zaxis: { title: 'Z (m relative to map zero)', autorange: 'reversed' },
          aspectmode: 'data',
          camera: { eye: { x: 1.6, y: 1.6, z: 0.9 } }
        },
        margin: { l: 0, r: 0, t: 50, b: 0 },
        template: 'plotly_white'
      };

      Plotly.newPlot('plot', traces, layout, { responsive: true });
    }

    // --- انتخاب حالت و رسم ---
    function renderProfile() {
      const { holes, df } = prepareData();
      const mode = modeSel.value;
      if (mode === '2d') render2D(holes, df);
      else render3D(holes, df);
    }
  </script>
</body>
</html>
